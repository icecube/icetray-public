#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
using namespace std;

#include <boost/assign.hpp>
#include <boost/assign/std/vector.hpp>
#include <boost/assign/std/set.hpp>
#include <boost/mpl/vector.hpp>
#include <boost/ref.hpp>
#include <boost/function.hpp>
#include <boost/bind.hpp>
#include <boost/format.hpp>
#include <sys/wait.h>
#include <setjmp.h>

#include <boost/program_options.hpp>
#include <iterator>
#include <iomanip>
#include <string.h>
#include <signal.h>

#include <icetray/I3Tray.h>
#include <icetray/I3TrayInfo.h>

#include <dataio/FrameIO.h>
#include <boost/archive/portable_binary_iarchive.hpp>


vector<string> tests_to_run;

namespace po = boost::program_options;

// A helper function to simplify the main part.
template<class T>
ostream& operator<<(ostream& os, const vector<T>& v)
{
  copy(v.begin(), v.end(), ostream_iterator<T>(cout, " ")); 
  return os;
}

po::options_description options("dataio-filter Options Summary");

void usage() {
  cerr << options << "\n";
}

int main(int argc, char* argv[])
{
  options.add_options()
    ("help,h", "this message")
    ("output-file,o", po::value< string >(), "output file")
    ("input-file,i", po::value< string >(), "input file")
    ("keep", po::value< vector<string> >(), "list of frame keys to keep")
    ;

  po::positional_options_description p;
  p.add("keep", -1);

  po::variables_map vm;

  try {
    po::store(po::command_line_parser(argc, argv)
	      .options(options)
	      .positional(p).run(), vm);

    po::notify(vm);
  } catch (const std::exception& e) {
    cout << argv[0] << ": " << e.what() << "\n";
    usage();
    return 1;
  }

  //  bool include = false;
  //  bool exclude = false;

  if (argc == 1)
    {
      usage();
      return 1;
    }

  if (vm.count("help")) {
    usage();
    return 1;
  }

  std::string ifilename;
  if (!vm.count("input-file"))
    {
      usage();
      return 1;
    }
  ifilename = vm["input-file"].as<string>();
  ifstream ifs(ifilename.c_str(), ios::binary);
      
  std::string ofilename;
  if (!vm.count("output-file"))
    {
      usage();
      return 1;
    }
  ofilename = vm["output-file"].as<string>();
  ofstream ofs(ofilename.c_str(), ios::binary);

  assert(ofs.good());

  set<std::string> keyset;

  if (vm.count("keep")) 
    {
      const vector<string>& keys =  vm["keep"].as< vector<string> >();
      for (unsigned i=0; i<keys.size(); i++)
	{
	  cout << keys[i] << " ";
	  keyset.insert(keys[i]);
	}
    }

  boost::archive::portable_binary_iarchive bia(ifs);
  I3TrayInfo trayinfo;
  bia >> trayinfo;

  {
    boost::archive::portable_binary_oarchive boa(ofs);
    boa << make_nvp("trayinfo", trayinfo);
  }

  unsigned frameno = 0;
  while (ifs.peek() != EOF)
    {
      frameno++;
      cerr << ".";
      cerr.flush();

      I3::dataio::FrameMap frame_map;

      try {
	I3::dataio::load_buffers<portable_binary_iarchive>(frame_map, ifs);
      } catch (const std::exception& e) {
	log_info("caught exception %s", e.what());
	break;
      }

      I3::dataio::FrameMap map_;
      map_.stream = frame_map.stream;
#warning this filtering problem is harder than this.  
#warning if you filter out geometry, your stop changes.      
      for (I3::dataio::FrameMap::iterator iter = frame_map.begin();
	   iter != frame_map.end();
	   iter++)
	{
	  if (keyset.find(iter->first) != keyset.end())
	    map_[iter->first] = iter->second;

	  cerr << iter->first << " => " << iter->second.first << "\n";
	}
      I3::dataio::save_buffers<portable_binary_oarchive>(map_, ofs);
      cerr << "----------------------------------------\n";
    }
}

