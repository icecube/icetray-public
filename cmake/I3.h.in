/**
 *  $Id$
 *  
 *  Copyright (C) 2004, 2005, 2006, 2007
 *  Troy D. Straszheim  <troy@icecube.umd.edu>
 *  and the IceCube Collaboration <http://www.icecube.wisc.edu>
 *  
 *  This file is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>
 *  
 */
#ifndef __CINT__
#  include <pyconfig.h>
#  ifdef __APPLE_CC__
#    ifdef _POSIX_C_SOURCE
#      undef _POSIX_C_SOURCE
#    endif
#  endif
#endif

#ifdef __cplusplus

#ifndef ICETRAY_I3_H_INCLUDED
#define ICETRAY_I3_H_INCLUDED

#include <I3/intel_compatibility.h>
//
//  Preprocessor def is set if we're building python bindings.  
//
#ifdef I3_PYBINDINGS_MODULE

// this has to match the type of libs you link to.  This should
// probably be configured by the boost tool and put on the command
// line instead of done here.
#include <boost/version.hpp>

// We used to disable threads throughout everything.
#if BOOST_VERSION < 103600
#define BOOST_DISABLE_THREADS
#endif

#define BOOST_PYTHON_DYNAMIC_LIB

#include <boost/python.hpp>
#include <boost/python/suite/indexing/indexing_suite.hpp>
#include <boost/python/suite/indexing/map_indexing_suite.hpp>
#include <boost/python/suite/indexing/vector_indexing_suite.hpp>

#include "container_conversions.h"
using scitbx::boost_python::container_conversions::from_python_sequence;
using scitbx::boost_python::container_conversions::to_tuple;
using scitbx::boost_python::container_conversions::variable_capacity_policy;

#endif // I3_PYBINDINGS_MODULE


// e.g. gcc 3.4.6 -> 30406
#define GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)

#if GCC_VERSION < 30400
#error gcc < 3.4 is not supported.  Please use gcc 3.4.x or newer.
#endif

#if 0
#if (GCC_VERSION >= 30400)
#define DSOLOCAL __attribute__ ((visibility ("hidden")))
#define DSOEXPORT __attribute__ ((visibility ("default")))
#endif
#else
#define DSOLOCAL
#define DSOEXPORT
#endif

#ifdef I3_USE_FAST_OMKEY_MAP
#define BOOST_STD_EXTENSION_NAMESPACE __gnu_cxx
#endif

#ifdef __APPLE_CC__
#  define _GLIBCPP_USE_C99 1
#  define _GLIBCXX_USE_C99 1
#  define M_PIl          3.1415926535897932384626433832795029L  /* pi */
#else
#  define HAVE_STRNLEN 1
#endif

// gives us the tasty bits like INT32_MAX
#define __STDC_LIMIT_MACROS

#include <cmath>
#include <math.h>
using std::isnan;

#define BOOST_NO_WREGEX

#ifdef I3_OPTIMIZE
#define BOOST_DISABLE_ASSERTS
#endif

#include <boost/version.hpp>


#include <boost/shared_ptr.hpp>
using boost::shared_ptr;
using boost::dynamic_pointer_cast;

// workaround for braindead rootcint.  doesn't recognize the using
// boost::shared_ptr.  I can just see this popping up to cause us
// unspeakable aggravation in the future...

#ifdef __CINT__
template <typename T>
struct shared_ptr : boost::shared_ptr<T> { };

#include "TError.h"
#include "zlib.h"

#endif

#ifdef I3_PYBINDINGS_MODULE

#include <icetray/I3FrameObject.h>
#include <I3/name_of.h>

//
// Tell python about basic conversions to/from const and FrameObject pointers
//
template <typename T>
void
register_pointer_conversions()
{
  using boost::python::implicitly_convertible;

  implicitly_convertible<shared_ptr<T>, shared_ptr<I3FrameObject> >();
  implicitly_convertible<shared_ptr<T>, shared_ptr<const T> >();
  implicitly_convertible<shared_ptr<T>, shared_ptr<const I3FrameObject> >();

  //  implicitly_convertible<shared_ptr<I3FrameObject>, shared_ptr<T> >();
  //  implicitly_convertible<shared_ptr<const I3FrameObject>, shared_ptr<const T> >();
  //  boost::python::register_ptr_to_python<boost::shared_ptr<T> >();
}

template <typename T> 
T 
identity_(T t) { return t; }


//
//  macros for general use
//
// GETSET implementation.  Pass the name of the Type, 
// the name of the member to access via Get*** Set***,
// and the return value policy.
// Used by the two macros below
#define GETSET_IMPL(ObjType, GotType, Name, CallPolicies)		\
  .def("Get" BOOST_PP_STRINGIZE(Name),					\
       (GotType (ObjType::*) ()) &ObjType:: BOOST_PP_CAT(Get,Name),	\
       CallPolicies)							\
  .def("Set" BOOST_PP_STRINGIZE(Name),					\
       &ObjType:: BOOST_PP_CAT(Set,Name))

// A version suitable for use with sequences
#define GETSET_IMPL_NOTYPE(ObjType, Name, CallPolicies)			\
  GET_IMPL_NOTYPE(ObjType, Name, CallPolicies)				\
  .def("Set" BOOST_PP_STRINGIZE(Name),					\
       &ObjType:: BOOST_PP_CAT(Set,Name))

#define GET_IMPL_NOTYPE(ObjType, Name, CallPolicies)			\
  .def("Get" BOOST_PP_STRINGIZE(Name),					\
       &ObjType:: BOOST_PP_CAT(Get,Name),				\
       CallPolicies)							\

// This is for member functions that return a Whatever&,
// where the actual Whatever is owned by the class.
#define GETSET_INTERNAL_REFERENCE(ObjType, GotType, Name)		\
  GETSET_IMPL(ObjType, GotType, Name, return_internal_reference<1>())

// This is for getters and setters that return PODS by value
#define GETSET(Objtype, GotType, Name)			\
  GETSET_IMPL(Objtype, GotType, Name, default_call_policies())

#define PROPERTY(Class, Prop, Fn) .add_property(BOOST_PP_STRINGIZE(Prop), &Class::Get##Fn, &Class::Set##Fn)
#define PROPERTY_TYPE(Class, Prop, GotType, Fn) .add_property(BOOST_PP_STRINGIZE(Prop), (GotType (Class::*) ()) &Class::Get##Fn, &Class::Set##Fn)

#include <ctype.h>
#include <string.h>
// convert from upper to lower CamelCase:
// ParticleType => particleType
// ATWDBinSize => atwdBinSize
char * lowerCamelCase(const char * str);
#define DECLARE_CAMELCASE_WRAPPER						\
	char * lowerCamelCase(const char * str) {				\
		int len,i;							\
		char* out;							\
		len = strlen(str);						\
		out = (char*)malloc(len+1);					\
		strcpy(out,str);						\
		out[0] = tolower(out[0]);					\
		for (i=1;i<len-1;i++) {						\
			if (!(isupper(out[i]) && isupper(out[i+1]))) break;	\
			out[i] = tolower(out[i]);				\
		}								\
		return out;							\
	}

// convert from upper CamelCase to snake_case
// ATWDBinSize => atwd_bin_size
// NBinsATWD0 => n_bins_atwd_0
char * snake_case(const char * str);
#define DECLARE_SNAKE_CASE_WRAPPER							\
	char * snake_case(const char * str) {						\
	        int i,j,len;								\
	        char* out;								\
	        j=0;									\
	        len = strlen(str);							\
	        out = (char*)malloc(2*len+1);						\
	        for (i=0;i<len;i++) {							\
	                out[i+j] = tolower(str[i]);					\
	                if ( (!isupper(str[i]) && isupper(str[i+1])) ||			\
	                     ((i<len-1) && isupper(str[i+1]) && islower(str[i+2])) ||	\
	                     (!isalpha(str[i+1]) && (str[i+1] != '\0')) ) {		\
	                        j++;							\
	                        out[i+j] = '_'; 					\
	                }								\
	        }									\
		out[len+j] = '\0';							\
	       	out = (char*)realloc(out,len+j+1);					\
	        return out;								\
	}


// add other housekeeping bits here
#define I3_PYTHON_MODULE(modname)						\
	DECLARE_CAMELCASE_WRAPPER						\
	DECLARE_SNAKE_CASE_WRAPPER						\
	BOOST_PYTHON_MODULE(modname)

#include <boost/preprocessor/seq.hpp>

// Trinary macros suitable for use with BOOST_PP_SEQ_FOR_EACH
#define WRAP_PROP(R, Class, Fn) .add_property(snake_case(BOOST_PP_STRINGIZE(Fn)), BOOST_PP_CAT(&Class::Get,Fn), BOOST_PP_CAT(&Class::Set,Fn))
#define WRAP_PROP_INTERNAL_REFERENCE(R, Class, Fn) 						\
   .add_property(snake_case(BOOST_PP_STRINGIZE(Fn)),					\
                 boost::python::make_function(BOOST_PP_CAT(&Class::Get,Fn), 			\
                                              boost::python::return_internal_reference<1>()), 	\
                 BOOST_PP_CAT(&Class::Set,Fn))
#define WRAP_PROP_RO(R, Class, Fn) .add_property(snake_case(BOOST_PP_STRINGIZE(Fn)), BOOST_PP_CAT(&Class::Get,Fn))
#define WRAP_PROP_RO_INTERNAL_REFERENCE(R, Class, Fn) 						\
   .add_property(snake_case(BOOST_PP_STRINGIZE(Fn)),					\
                 boost::python::make_function(BOOST_PP_CAT(&Class::Get,Fn), 			\
                                              boost::python::return_internal_reference<1>())) 
#define WRAP_RW(R, Class, Member) .def_readwrite(BOOST_PP_STRINGIZE(Member), &Class::Member)
#define WRAP_RO(R, Class, Member) .def_readonly(BOOST_PP_STRINGIZE(Member), &Class::Member)
#define WRAP_DEF(R, Class, Fn) .def(BOOST_PP_STRINGIZE(Fn), &Class::Fn)
#define WRAP_DEF_RECASE(R, Class, Fn) .def(snake_case(BOOST_PP_STRINGIZE(Fn)), &Class::Fn)
#define WRAP_GET(R, Class, Name) GET_IMPL_NOTYPE(Class, Name, default_call_policies())
#define WRAP_GETSET(R, Class, Name) GETSET_IMPL_NOTYPE(Class, Name, default_call_policies())
#define WRAP_GET_INTERNAL_REFERENCE(R, Class, Name) GET_IMPL_NOTYPE(Class, Name, return_internal_reference<1>())
#define WRAP_GETSET_INTERNAL_REFERENCE(R, Class, Name) GETSET_IMPL_NOTYPE(Class, Name, return_internal_reference<1>())
#define WRAP_ENUM_VALUE(R, Class, Name) .value(BOOST_PP_STRINGIZE(Name),Class::Name)

// Class registration stuff
#define I3_REGISTRATION_FN_DECL(r, data, t) void BOOST_PP_CAT(register_,t)();

// Hey jvs:  this conflicts with the I3_REGISTER in project icetray
// #define I3_REGISTER(r, data, t) BOOST_PP_CAT(register_,t)();

#endif

#endif // ICETRAY_I3_H_INCLUDED
#endif // __cplusplus

