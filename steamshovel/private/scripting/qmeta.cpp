#include <set>
#include <iostream>

#include <boost/python.hpp>
#include <boost/bind.hpp>
#include <boost/mpl/vector.hpp>

#include <QMetaObject>
#include <QMetaMethod>
#include <QVariant>
#include <QString>

#include <icetray/I3Logging.h>

#include "gil.h"
#include "qmeta.h"
#include "qmeta_args.h"
#include "qstring_converter.h"

namespace scripting{

SET_LOGGER("qmeta");

namespace bp = boost::python;

/**
 * Keeper of runtime qmeta information
 */
static struct qmeta_info{
	bp::object qmeta_mod_;
	typedef std::map<QObject*, bp::object> instance_map;
	typedef std::map<const QMetaObject*, bp::object> metaclass_map;
	metaclass_map metaclasses_;
	instance_map instances_;
} qmeta_info;

BOOST_PYTHON_MODULE( qmeta )
{
	// disable autogenerated portion of function docstrings, as they are not useful
	bp::docstring_options docopt( false, false, false );
	QStringConverter();
}

void QMeta::pre_init()
{
#if PY_MAJOR_VERSION >= 3
	PyImport_AppendInittab((char *) "qmeta", &PyInit_qmeta);
#else
	PyImport_AppendInittab((char *) "qmeta", &initqmeta);
#endif
}

void QMeta::post_init()
{
	ScopedGIL gil;
	register_metatypes();
	try {
		qmeta_info.qmeta_mod_ = bp::import("qmeta");
		qmeta_info.qmeta_mod_.attr("_all_objects") = bp::list();
	} catch( bp::error_already_set& e ){
		PyErr_Print();
		throw;
	}
    log_debug("QMeta has initialized");
}

/** Extract the metamethod name */
static std::string make_method_name( QMetaMethod method )
{
#if QT_VERSION >= 0x050000
	std::string sig = method.name().data();
	return sig;
#else
	std::string sig = method.signature();
	return sig.substr(0, sig.find('('));
#endif
}

static std::set< std::string > split( std::string list, std::string separators=", " ){
	std::set< std::string> ret;
	size_t sep;
	while( (sep = list.find_first_of(separators)) != list.npos ){
		ret.insert( list.substr(0,sep) );
		list = list.substr(sep+1);
	}
	ret.insert(list);
	return ret;
}

static std::set< std::string > get_scriptable_props( const QMetaObject* meta ){
	std::set< std::string > props;
	int idx = meta->indexOfClassInfo( "qmeta_scriptable_props" );
	if( idx != -1 ){
		std::string list( meta->classInfo( idx ).value() );
		log_debug_stream( "Scriptable properties for " << meta->className() << ":" << list );
		props = split(list);
	}
	else{
		for( int i = 0; i< meta->propertyCount(); ++i ){
			QMetaProperty prop = meta->property(i);
			props.insert( prop.name() );
		}
	}
	return props;
}

static std::set< std::string > get_scriptable_slots( const QMetaObject* meta ){
	std::set< std::string > props;
	int idx = meta->indexOfClassInfo( "qmeta_scriptable_slots" );
	if( idx != -1 ){
		std::string list( meta->classInfo( idx ).value() );
		log_debug_stream( "Scriptable properties for " << meta->className() << ":" << list );
		props = split(list);
	}
	else{
		for( int i = 0; i< meta->methodCount(); ++i ){
			QMetaMethod method = meta->method(i);
			props.insert( make_method_name(method) );
		}
	}
	return props;
}

bp::object get_classdef( const QMetaObject* meta )
{
	qmeta_info::metaclass_map::const_iterator iter;
	if( (iter=qmeta_info.metaclasses_.find( meta )) != qmeta_info.metaclasses_.end()){
		/* This class has been previously exported */
		return (*iter).second;
	}

	log_debug_stream( "Exporting metaobject " << meta->className() );
	const char* classname = meta->className();
	//bp::class_<QObject, boost::shared_ptr<QObject>, boost::noncopyable> classdef(classname);
	bp::class_<QObject, boost::noncopyable> classdef(classname, bp::no_init);
	classdef.attr("__module__") = "qmeta";

	std::set< std::string > scriptable = get_scriptable_props( meta );
	/* Export properties */
	for( int i = 0; i < meta->propertyCount(); ++i ){
		QMetaProperty prop = meta->property(i);
		std::string name = prop.name();
		if( scriptable.count(name) == 0 )
			name = "_" + name;
		try{
			if( prop.isWritable() ){
				classdef.add_property( name.c_str(), make_metaproperty_reader(prop),
				                                     make_metaproperty_writer(prop) );
			}
			else{
				classdef.add_property( name.c_str(), make_metaproperty_reader(prop) );
			}
		}
		catch( QMeta::error& e ){
			log_debug_stream ( "Could not export property " << prop.name() );
		}
	}

	/* Export slots */
	scriptable = get_scriptable_slots( meta );
	for( int i = 0; i < meta->methodCount(); ++i ){
		QMetaMethod method = meta->method(i);
		if( method.methodType() != QMetaMethod::Slot && method.methodType() != QMetaMethod::Method) {
			continue;
		}
		if( method.access() != QMetaMethod::Public ) continue;
		std::string name = make_method_name(method);
		if( name == "deleteLater" ) continue;  /* because calling this from python is a bad idea */
		if( scriptable.count(name) == 0 )
			name = "_" + name;
		classdef.def( name.c_str(), make_invoker(method) );
	}

	qmeta_info.metaclasses_[ meta ] = classdef;
	return std::move(classdef);
}

void QMeta::exportObject( QObject* q ){
	ScopedGIL gil;
	const QMetaObject* meta = q->metaObject();
	try{
		bp::object classdef = get_classdef( meta );
		bp::object mod = qmeta_info.qmeta_mod_;
		bp::object exported( bp::ptr(q) );
		exported.attr("__class__") = classdef;
		qmeta_info.instances_[ q ] = exported;
		mod.attr("_all_objects").attr("append")(exported);
	}
	catch( bp::error_already_set& e ){
		PyErr_Print();
	}
}

void QMeta::addToGlobalNamespace( QObject* q, const std::string& name ){
	ScopedGIL gil;
	log_debug_stream("To global namespace: " << name );
	qmeta_info::instance_map::iterator i = qmeta_info.instances_.find(q);
	if( i != qmeta_info.instances_.end() ){
		bp::import("__main__").attr(name.c_str()) = (*i).second;
	}
	else
		throw QMeta::error("Object is not part of qmeta");
}


void QMeta::addToParent( QObject* parent, QObject* child, const std::string& attrname ){
	ScopedGIL gil;
	log_debug_stream( "To parent namespace: " << attrname );
	qmeta_info::instance_map::iterator p = qmeta_info.instances_.find(parent);
	qmeta_info::instance_map::iterator c = qmeta_info.instances_.find(child);
	if( p == qmeta_info.instances_.end() ){
		throw QMeta::error("Parent is not part of qmeta");
	}
	if( c == qmeta_info.instances_.end() ){
		throw QMeta::error("Child is not part of qmeta");
	}
	bp::object p_obj = (*p).second;
	bp::object c_obj = (*c).second;
	try{
#if PY_MAJOR_VERSION >= 3
		if( bp::import("builtins").attr("hasattr")(p_obj, attrname.c_str())){
#else
		if( bp::import("__builtin__").attr("hasattr")(p_obj, attrname.c_str())){
#endif
			log_warn_stream("Overriding existing attribute in parent object: " << attrname );
		}
		p_obj.attr(attrname.c_str()) = c_obj;
	}
	catch( bp::error_already_set& e ){
		PyErr_Print();
	}
}

} // namespace scripting
