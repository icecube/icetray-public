#ifndef I3_SHOVEL_RENDERING_SCENE_H
#define I3_SHOVEL_RENDERING_SCENE_H

#include <vector>
#include <set>
#include <boost/unordered_map.hpp>
#include <boost/any.hpp>
#include <boost/utility/enable_if.hpp>
#include <boost/type_traits/is_base_of.hpp>
#include <icetray/I3Logging.h>
#include "ArtistFwd.h"
#include "SceneObject.h"
#include "timewindow.h"

class I3Camera;
class QGLWidget;
class Scene;
class Scenario;

/**
 * A group of SceneObjects as generated by a particular artist.  The Scene uses these
 * to keep the output of Artists separate from one another, so that artist outputs
 * can be removed or added as necessary.
 */
class SceneGroup : private std::vector<SceneObject*> {

protected:
	/// The artist that generated this group
	ArtistPtr source_;
	/// True if this group has at least one SceneOverlay aboard
	bool overlays_;

public:

	SceneGroup( ArtistPtr source );
	virtual ~SceneGroup();

	/**
	 *Add a SceneObject to the group
	 */
	void add( SceneObject* s ){ push_back( s ); }

	/* Specialized form of add() for types inheriting SceneOverlay */
	template<typename T>
	typename boost::enable_if_c< boost::is_base_of<SceneOverlay,T>::value, void >::type
	add( T* s ){
		push_back( s );
		overlays_ = true;
	}

	ArtistPtr getSource() const { return source_; }

	friend class Scene;

};

/** Global Scene state to be shared with other graphics classes
 *
 * This class is made available to Artists during creation of SceneObjects, allowing
 * them access to the QGLWidget for texturing purposes, a reference to the TimeWindow
 * driving the visualization, and the scaling factor for DPI-sensitive outputs.
 *
 * This object also keeps size hints for overlays, mapped by the artists that generated
 * them.  Artists can access this information to determine the user-specified size
 * of the overlays they are creating.
 */
class SceneState{
public:
	const TimeWindow* times;
	QGLWidget* gl;
	double scaling_factor;

	// For a single artist, an OverlayHints is a list of hints for each overlay the artist generated,
	// sorted in the order in which they were created.
	typedef std::vector< SceneOverlay::SizeHint > OverlayHints;
	// Each artist gets a single OverlayHints
	class OverlayHintsMap: public boost::unordered_map< ArtistPtr, OverlayHints > {
		typedef boost::unordered_map< ArtistPtr, OverlayHints > base;
	public:
		typedef base::const_iterator const_iterator;
		typedef base::iterator iterator;
		const_iterator find( ArtistPtr p )const{ return base::find( p ); }
		iterator find( ArtistPtr p ){ return base::find( p ); }
		// does only linear search, but is not called very often
		const_iterator find( const Artist* p )const{
			for( const_iterator iter = begin(); iter != end(); ++iter ){
				if( iter->first.get() == p )
					return iter;
			}
			return end();
		}
	};

	OverlayHintsMap overlayHintsMap_;

	SceneState() : times(0), gl(0), scaling_factor(1.0) {}
};

/* create smart pointer types SceneGroupPtr and SceneGroupConstPtr */
I3_POINTER_TYPEDEFS( SceneGroup );

class Scene{
	SET_LOGGER("scene");

public:
	Scene() : fixed_state_(false) {}

	/**
	 * RAII class for scaling this scene's overlays by a given scaling factor
	 */
	class WithOverlaysScaled {
	private:
		boost::shared_ptr<Scene> parent_;
		Scenario* scenario_;
		SceneState::OverlayHintsMap old_hints_;

	public:
		WithOverlaysScaled( const boost::shared_ptr<Scene>& parent, Scenario* scenario, double scaling_factor );
		~WithOverlaysScaled();
	};


	/// set the pointers for the underlying SceneState
	void setState( QGLWidget* w, const TimeWindow* win ){ state_.gl = w; state_.times = win; }

	/**
	 * Perform OpenGL rendering pass with the given vistime and camera settings
	 */
	void draw( double vistime, const I3Camera& camera );

	/**
	 * Handle a mouse selection operation with the given vistime and camera settings,
	 * as well as the given mouse coordinates.  Return the selectionContent of the
	 * clicked SceneObject, if any
	 */
	boost::any pick( double vistim, const I3Camera& camera, int winx, int winy );

	/// Add a new group
	void add( SceneGroupPtr s );
	void add( SceneGroup* s ){ add(SceneGroupPtr(s)); }
	/// Remove the content previously generated by this artist
	void dropOutputs( ArtistPtr ptr );
	/// Remove content and forget any metadata about the artist
	void dropSource( ArtistPtr ptr );
	/// Equivalent to dropSource on all sources
	void dropAll();

	/// return the source of the given overlay
	ArtistPtr overlaySource( SceneOverlay* overlay );

	/// Search over all current SceneObjects and find any whose selectionContent == s
	template <typename T, typename S >
	std::vector< T* > selectionsByKey( S s, double vistime );

private:
	SceneState state_;
	bool fixed_state_;
	std::set< SceneGroupPtr > groups_;
	std::vector< SceneObject* > objects_;

	/// access the underlying SceneState.
	const SceneState& state() const { return state_; }

	void updateAllHints();
	void gatherHints( SceneState::OverlayHints&, SceneGroupPtr );
	void applyHints( SceneState::OverlayHints&, SceneGroupPtr );

	friend class Scenario;
};


template <typename T, typename S >
std::vector< T* > Scene::selectionsByKey( S s, double vistime ){
	std::vector< T* > ret;
	for( std::vector< SceneObject* >::iterator i = objects_.begin();
	     i != objects_.end(); ++i )
	{
		T* ob = dynamic_cast<T*>(*i);
		if( ob && ob->isSelectable( vistime ) ){
			try{
				S val = boost::any_cast<S>(ob->selectionContent());
				if( val == s ){
					ret.push_back(ob);
				}
			}
			catch( boost::bad_any_cast& ){
			}
		}
	}
	return ret;
}

#endif /* I3_SHOVEL_RENDERING_SCENE_H */
